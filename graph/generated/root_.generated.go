// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"apiGrapqlEntgo/graph/model"
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Course struct {
		CreatedAt      func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Period         func(childComplexity int) int
		ProfessorID    func(childComplexity int) int
		SubjectID      func(childComplexity int) int
		Year           func(childComplexity int) int
	}

	Mutation struct {
		CreateCourse     func(childComplexity int, input model.NewCourse) int
		CreateProfessor  func(childComplexity int, input model.NewProfessor) int
		CreateSubject    func(childComplexity int, input model.NewSubject) int
		RemoveCourse     func(childComplexity int, year int, period int, subjectID string) int
		RemoveCourseByID func(childComplexity int, id int) int
		RemoveProfessor  func(childComplexity int, id string) int
		RemoveSubject    func(childComplexity int, id string) int
		UpdateCourse     func(childComplexity int, year int, period int, subjectID string, input model.NewCourse) int
		UpdateCourseByID func(childComplexity int, id int, input model.NewCourse) int
		UpdateProfessor  func(childComplexity int, id string, input model.NewProfessor) int
		UpdateSubject    func(childComplexity int, id string, input model.NewSubject) int
	}

	Professor struct {
		BirthDate      func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		LastName       func(childComplexity int) int
		Name           func(childComplexity int) int
	}

	Query struct {
		Course     func(childComplexity int, year int, period int, subjectID string) int
		CourseByID func(childComplexity int, id int) int
		Courses    func(childComplexity int) int
		Professor  func(childComplexity int, id string) int
		Professors func(childComplexity int) int
		Subject    func(childComplexity int, id string) int
		Subjects   func(childComplexity int) int
	}

	Subject struct {
		Active         func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		Description    func(childComplexity int) int
		ID             func(childComplexity int) int
		LastModifiedAt func(childComplexity int) int
		Name           func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Course.created_at":
		if e.complexity.Course.CreatedAt == nil {
			break
		}

		return e.complexity.Course.CreatedAt(childComplexity), true

	case "Course.id":
		if e.complexity.Course.ID == nil {
			break
		}

		return e.complexity.Course.ID(childComplexity), true

	case "Course.last_modified_at":
		if e.complexity.Course.LastModifiedAt == nil {
			break
		}

		return e.complexity.Course.LastModifiedAt(childComplexity), true

	case "Course.period":
		if e.complexity.Course.Period == nil {
			break
		}

		return e.complexity.Course.Period(childComplexity), true

	case "Course.professor_id":
		if e.complexity.Course.ProfessorID == nil {
			break
		}

		return e.complexity.Course.ProfessorID(childComplexity), true

	case "Course.subject_id":
		if e.complexity.Course.SubjectID == nil {
			break
		}

		return e.complexity.Course.SubjectID(childComplexity), true

	case "Course.year":
		if e.complexity.Course.Year == nil {
			break
		}

		return e.complexity.Course.Year(childComplexity), true

	case "Mutation.createCourse":
		if e.complexity.Mutation.CreateCourse == nil {
			break
		}

		args, err := ec.field_Mutation_createCourse_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCourse(childComplexity, args["input"].(model.NewCourse)), true

	case "Mutation.createProfessor":
		if e.complexity.Mutation.CreateProfessor == nil {
			break
		}

		args, err := ec.field_Mutation_createProfessor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProfessor(childComplexity, args["input"].(model.NewProfessor)), true

	case "Mutation.createSubject":
		if e.complexity.Mutation.CreateSubject == nil {
			break
		}

		args, err := ec.field_Mutation_createSubject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSubject(childComplexity, args["input"].(model.NewSubject)), true

	case "Mutation.removeCourse":
		if e.complexity.Mutation.RemoveCourse == nil {
			break
		}

		args, err := ec.field_Mutation_removeCourse_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveCourse(childComplexity, args["year"].(int), args["period"].(int), args["subject_id"].(string)), true

	case "Mutation.removeCourseByID":
		if e.complexity.Mutation.RemoveCourseByID == nil {
			break
		}

		args, err := ec.field_Mutation_removeCourseByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveCourseByID(childComplexity, args["id"].(int)), true

	case "Mutation.removeProfessor":
		if e.complexity.Mutation.RemoveProfessor == nil {
			break
		}

		args, err := ec.field_Mutation_removeProfessor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveProfessor(childComplexity, args["id"].(string)), true

	case "Mutation.removeSubject":
		if e.complexity.Mutation.RemoveSubject == nil {
			break
		}

		args, err := ec.field_Mutation_removeSubject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveSubject(childComplexity, args["id"].(string)), true

	case "Mutation.updateCourse":
		if e.complexity.Mutation.UpdateCourse == nil {
			break
		}

		args, err := ec.field_Mutation_updateCourse_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCourse(childComplexity, args["year"].(int), args["period"].(int), args["subject_id"].(string), args["input"].(model.NewCourse)), true

	case "Mutation.updateCourseByID":
		if e.complexity.Mutation.UpdateCourseByID == nil {
			break
		}

		args, err := ec.field_Mutation_updateCourseByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCourseByID(childComplexity, args["id"].(int), args["input"].(model.NewCourse)), true

	case "Mutation.updateProfessor":
		if e.complexity.Mutation.UpdateProfessor == nil {
			break
		}

		args, err := ec.field_Mutation_updateProfessor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProfessor(childComplexity, args["id"].(string), args["input"].(model.NewProfessor)), true

	case "Mutation.updateSubject":
		if e.complexity.Mutation.UpdateSubject == nil {
			break
		}

		args, err := ec.field_Mutation_updateSubject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSubject(childComplexity, args["id"].(string), args["input"].(model.NewSubject)), true

	case "Professor.birth_date":
		if e.complexity.Professor.BirthDate == nil {
			break
		}

		return e.complexity.Professor.BirthDate(childComplexity), true

	case "Professor.created_at":
		if e.complexity.Professor.CreatedAt == nil {
			break
		}

		return e.complexity.Professor.CreatedAt(childComplexity), true

	case "Professor.id":
		if e.complexity.Professor.ID == nil {
			break
		}

		return e.complexity.Professor.ID(childComplexity), true

	case "Professor.last_modified_at":
		if e.complexity.Professor.LastModifiedAt == nil {
			break
		}

		return e.complexity.Professor.LastModifiedAt(childComplexity), true

	case "Professor.last_name":
		if e.complexity.Professor.LastName == nil {
			break
		}

		return e.complexity.Professor.LastName(childComplexity), true

	case "Professor.name":
		if e.complexity.Professor.Name == nil {
			break
		}

		return e.complexity.Professor.Name(childComplexity), true

	case "Query.course":
		if e.complexity.Query.Course == nil {
			break
		}

		args, err := ec.field_Query_course_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Course(childComplexity, args["year"].(int), args["period"].(int), args["subject_id"].(string)), true

	case "Query.courseByID":
		if e.complexity.Query.CourseByID == nil {
			break
		}

		args, err := ec.field_Query_courseByID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CourseByID(childComplexity, args["id"].(int)), true

	case "Query.courses":
		if e.complexity.Query.Courses == nil {
			break
		}

		return e.complexity.Query.Courses(childComplexity), true

	case "Query.professor":
		if e.complexity.Query.Professor == nil {
			break
		}

		args, err := ec.field_Query_professor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Professor(childComplexity, args["id"].(string)), true

	case "Query.professors":
		if e.complexity.Query.Professors == nil {
			break
		}

		return e.complexity.Query.Professors(childComplexity), true

	case "Query.subject":
		if e.complexity.Query.Subject == nil {
			break
		}

		args, err := ec.field_Query_subject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Subject(childComplexity, args["id"].(string)), true

	case "Query.subjects":
		if e.complexity.Query.Subjects == nil {
			break
		}

		return e.complexity.Query.Subjects(childComplexity), true

	case "Subject.active":
		if e.complexity.Subject.Active == nil {
			break
		}

		return e.complexity.Subject.Active(childComplexity), true

	case "Subject.created_at":
		if e.complexity.Subject.CreatedAt == nil {
			break
		}

		return e.complexity.Subject.CreatedAt(childComplexity), true

	case "Subject.description":
		if e.complexity.Subject.Description == nil {
			break
		}

		return e.complexity.Subject.Description(childComplexity), true

	case "Subject.id":
		if e.complexity.Subject.ID == nil {
			break
		}

		return e.complexity.Subject.ID(childComplexity), true

	case "Subject.last_modified_at":
		if e.complexity.Subject.LastModifiedAt == nil {
			break
		}

		return e.complexity.Subject.LastModifiedAt(childComplexity), true

	case "Subject.name":
		if e.complexity.Subject.Name == nil {
			break
		}

		return e.complexity.Subject.Name(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputNewCourse,
		ec.unmarshalInputNewProfessor,
		ec.unmarshalInputNewSubject,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/mutation.graphql", Input: `type Mutation {
	createProfessor(input: NewProfessor!): Professor!
	removeProfessor(id: String!): Professor!
	updateProfessor(id: String!, input:NewProfessor!): Professor!
	createSubject(input: NewSubject!): Subject!
	removeSubject(id: String!): Subject!
	updateSubject(id: String!, input:NewSubject!): Subject!
	createCourse(input: NewCourse!): Course!
	removeCourseByID(id: Int!): Course!
	removeCourse(year: Int!, period: Int!, subject_id: String!): Course!
	updateCourseByID(id: Int!, input:NewCourse!): Course!
	updateCourse(year: Int!, period: Int!, subject_id: String!, input:NewCourse!): Course!
}
`, BuiltIn: false},
	{Name: "../schema/query.graphql", Input: `type Query {
	professors: [Professor!]!
	professor(id: String!): Professor!
	subjects: [Subject!]!
	subject(id: String!): Subject!
	courses: [Course!]!
	courseByID(id: Int!): Course!
	course(year: Int!, period: Int!, subject_id: String!): Course!
}
`, BuiltIn: false},
	{Name: "../schema/types.graphql", Input: `input NewProfessor {
	id: String!
	name: String!
	last_name: String!
	birth_date: String!
}

type Professor {
	id: String!
	name: String!
	last_name: String!
	birth_date: String!
	created_at: String!
	last_modified_at: String!
}

input NewSubject {
	id: String!
	name: String!
	description: String!
	active: Boolean!
}

type Subject {
	id: String!
	name: String!
	description: String!
	active: Boolean!
	created_at: String!
	last_modified_at: String!
}

input NewCourse {
	year: Int!
	period: Int!
	professor_id: String!
	subject_id: String!
}

type Course {
	id: Int!
	year: Int!
	period: Int!
	professor_id: String!
	subject_id: String!
	created_at: String!
	last_modified_at: String!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
